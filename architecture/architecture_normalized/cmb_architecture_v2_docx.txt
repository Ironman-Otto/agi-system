CMB Architecture Version 2
Introduction
The Cognitive Message Bus (CMB) is the communication backbone of an AGI system, enabling modular components to exchange information seamlessly. It functions as a message bus, which is a combination of a common data model, a common command set, and a messaging infrastructure allowing different systems (modules) to communicate through shared interfaces. The CMB decouples modules by providing an asynchronous, channel-based messaging system. 
In Version 2 of the CMB architecture, improvements have been incorporated to enhance completeness, clarity, and robustness based on prior feedback. These include clearer channel definitions, a standard message format with priorities and expiration, code examples for usage, and provisions for future enhancements (like security and direct addressing).
Design Goals and Key Features
Decoupled Communication: Modules do not call each other directly. Instead, they send messages over the bus, ensuring loose coupling and modularity. This allows modules to be added or removed with minimal impact on others.
Asynchronous Messaging: Communication is asynchronous via publish/subscribe and push/pull patterns, so senders and receivers operate independently. No module is blocked waiting for another, improving concurrency and system responsiveness.
Multiple Channels (Topic Domains): Messages are organized into distinct channels by topic/domain (e.g. Control, Perception, Memory). This segmentation prevents irrelevant traffic from reaching modules and helps manage complexity. Each channel has its own message router and topic namespace, supporting parallel message flows.
Standard Message Structure: All messages adhere to a common format (the CognitiveMessage), which includes metadata like source, targets, priority, etc. This ensures a canonical data model for communication. The consistent format simplifies processing and logging of messages system-wide.
Extensibility and Scalability: New modules or channels can be introduced without altering the core bus logic. The underlying ZeroMQ-based infrastructure is network-capable (TCP sockets), allowing distribution of modules across processes or machines. As long as modules know the channel and message schema, they can participate.
Diagnostics and Logging: A dedicated diagnostic channel (and logging module) exists to monitor and record bus traffic. Every message can be logged or inspected for debugging or analysis, supporting system transparency and introspection.
Prioritization and TTL: Each message carries a priority level and a time-to-live (TTL). While not all v2 components fully utilize these yet, they lay the groundwork for future enhancements like prioritizing urgent messages and discarding stale messages automatically.
Channels and Routing
CMB Channels are logical communication pathways, each identified by an acronym and served by its own message router. Version 2 continues to use the original channels from version 1 and adds any needed new ones. Table below lists the core channels in the system and their roles:
CC (Control Channel): Used for high-level control signals and directives. For example, the Executive module sends commands (e.g., "start behavior X") to subordinate modules via CC.
SMC (Symbolic Message Channel): Handles symbolic or discrete knowledge exchange. Cognitive reasoning modules might share symbolic facts, NLP insights, or logic statements over SMC for higher-level reasoning.
VB (Vector Bus): Carries vectorized data (embeddings, sensory feature vectors, etc.). Perception modules publish processed sensor data (like image feature vectors or audio spectrograms) on the VB for consumption by cognitive or memory modules.
BFC (Behavioral Flow Channel): Manages sequences of actions or behaviors. Planning and behavior coordination messages (task status, next action triggers) flow through BFC to ensure complex behaviors are executed in order.
DAC (Diagnostic and Awareness Channel): Used for diagnostics, logging, and self-awareness signals. Modules send status updates, heartbeat messages, or logs to this channel. A special CMB Logger module on DAC records all important events, enabling system monitoring and introspection.
EIG (External Interface Gateway): Interface to the external world or external systems. Any inbound commands from a user interface or API, and outbound messages to external services, pass through EIG. This isolates external I/O at a single gateway channel.
PC (Perception Channel): Conveys raw perceptual inputs and low-level sensory data. Perceptual modules (vision, auditory, etc.) publish their observations or detections on PC, which may be consumed by memory or interpretive modules for further processing.
MC (Memory Channel): Dedicated to memory storage and retrieval operations. Queries to the memory module, memory recall results, or knowledge base updates are transmitted via MC so that other modules can stay informed of changes in the knowledge state.
IC (Introspection Channel): Used by introspective processes that evaluate or analyze the agent’s own cognitive state. For example, an introspection module might request explanations for decisions or check system consistency over IC, with relevant modules responding on the same channel.
TC (Threat Channel): Reserved for threat detection and mitigation messages. If any module (or an external sensor) perceives an anomaly or threat, it sends an alert on TC. Security or safety modules subscribe to TC to take appropriate action (such as shutting down a component or alerting an operator).
These channel definitions are reflected in the central configuration. Each channel is assigned a unique base TCP port for its router (e.g. "CC": 6001 for Control Channel). By default, the router for a channel uses two consecutive ports: one for incoming messages and the next for outgoing. For example, if the Control Channel base is 6001, the router listens for incoming messages on 6001 and publishes outgoing messages on 6002 (as 6001+1). This scheme ensures no port conflicts and a known mapping from channel name to network port.
CMB Router
For each channel, a CMBRouter instance is responsible for shuttling messages from senders to receivers. The router binds a ROUTER (or PULL) socket to the channel’s input port to receive messages, and a PUB socket to the output port to broadcast messages to subscribers. The router is channel-agnostic – it does not inspect message content beyond looking at the target addresses. It simply ensures that any message arriving on the input is published on the output with the appropriate topic label.
Under the hood, when a module sends a message into the bus, it goes to the channel’s ROUTER socket. The router then wraps or queues the message and republishes it via the PUB socket. Subscribers (modules) on that channel receive it if they are subscribed to the matching topic. In the current design, the message’s target field is used as the PUB topic. The router uses the list of targets in the message to send a copy to each target name. Each target name becomes the topic for one PUB message containing the original message bytes. Modules subscribe to their own name (or other relevant topic) to receive messages intended for them. This acts like a direct addressing scheme on the bus:
If a message has targets: ["behavior"], only the module(s) subscribed to topic "behavior" will get it (typically the Behavior module itself).
If multiple targets are listed (e.g. ["memory", "behavior"]), the router will publish it twice, once with topic "memory" and once with "behavior", delivering to both modules.
(Future feature:) A special target like "all" could be used for broadcast to every subscriber, though by default modules only subscribe to their own name. In version 2, broadcast could be achieved by having modules also subscribe to a shared topic (if configured) or by explicitly listing all intended recipients.
Router concurrency and identity: The router’s receiving socket is a ZeroMQ ROUTER type, which allows addressing and asynchronous handling of multiple senders. In v2, the router currently doesn’t use the identity feature beyond what ZeroMQ needs internally (we read and ignore the sender identity frame). However, this design decision paves the way for future enhancements such as:
Direct Request-Reply: Modules could send a message and await a routed reply addressed back to them via the router (using the ROUTER/DEALER pattern).
Authentication or Filtering: Identities could be used to authenticate modules or filter messages (e.g., only allow certain modules to send on certain channels).
Each router runs in its own thread (or process) for scalability. In the provided demo setup, a router is launched for the Control Channel to enable executive-behavior communication. In a full system, one would run a router instance per channel to activate the entire bus. This could be done by launching multiple router processes (one per channel) or a single process creating multiple router threads via the CMBRouter.start() method. Once running, routers require no further intervention – they continuously forward messages as they arrive.
Module Endpoints and Communication Model
Modules interface with the CMB through a Module Endpoint, which abstracts the underlying ZeroMQ sockets. The ModuleEndpoint class manages a pair of sockets: a PUSH socket for sending messages into the bus, and a SUB socket for receiving messages from the bus. This hides the complexity of socket setup and provides simple send() and receive() methods to the module developer.
When a module starts up, it creates a ModuleEndpoint, providing its unique module name and specifying which channel’s ports to connect to. For example, a Behavior module that listens on the Control Channel (CC) might configure its endpoint as follows:
cc_pub = get_channel_port("CC") + 1  # outbound PUB port for CC
cc_push = get_channel_port("CC") + 0  # inbound PUSH/ROUTER port for CC
behavior_endpoint = ModuleEndpoint("behavior", pub_port=cc_pub, push_port=cc_push)
Source: behavior_stub.py
In this snippet, ModuleEndpoint("behavior", ...) subscribes its SUB socket to topic "behavior" on the Control Channel’s PUB port, and connects its PUSH socket to the Control Channel’s input port. From this point on, the Behavior module can receive any message addressed to "behavior" on CC, and it can send messages out via CC by calling the endpoint’s send function. Similarly, an Executive module or any other module would instantiate its endpoint with the appropriate channel ports and module name.
Sending a message: To send a message, a module creates a CognitiveMessage object (or uses the CognitiveMessage.create() helper) and calls the endpoint’s send(message). The endpoint handles serializing the message to bytes and pushing it to the channel router. For example, the Executive module might do the following to command the Behavior module:
# In Executive module, send a directive to Behavior over Control Channel
msg = CognitiveMessage.create(
    source="executive",
    targets=["behavior"],
    payload={"directive": "start_behavior", "behavior": "explore_area"},
    priority=70
)
executive_endpoint.send(msg)
Source: executive_stub.py
Here, the Executive’s message specifies its own name (source="executive") and the intended recipient (targets=["behavior"]), along with a payload containing the instruction details. The priority=70 indicates this is a high-priority message (on a scale that typically defaults to 50). When executive_endpoint.send(msg) is called, the message is forwarded to the CC router, which will route it to the Behavior module as described earlier. The sending call is non-blocking; the Executive can continue doing other work without waiting for a response.
Receiving a message: On the other side, the Behavior module’s endpoint will deliver the message to the Behavior when it calls receive(). The module might have a loop waiting for incoming messages. For example:
# In Behavior module, receiving messages from Control Channel
msg = behavior_endpoint.receive()  # blocking call, waits for next message
print(f"Received message from {msg.source}: {msg.payload}")
# ... process the message ...
Source: behavior_stub.py
In this snippet, behavior_endpoint.receive() blocks until a message tagged for "behavior" is published by the router. The returned object msg is a CognitiveMessage instance that the Behavior module can inspect. In this case, it would find msg.source == "executive" and msg.payload == {"directive": "start_behavior", "behavior": "explore_area"} as sent above. The behavior module would then act on that directive (e.g., initiate the requested behavior).
Publish/Subscribe Mechanism: Note that a module only receives messages for topics it subscribes to. By default, ModuleEndpoint subscribes to the module’s own name (ensuring it gets direct messages). Modules can subscribe to additional topics if needed by creating additional ModuleEndpoint instances or by extending the subscription (the current implementation binds one subscription per endpoint). For instance, a logging or monitoring module might subscribe to multiple modules’ topics or use wildcards (if supported) to capture broader traffic. This is analogous to a Selective Consumer pattern where each module is only interested in certain message types or senders.
Multiple Senders and Receivers: The CMB supports multiple modules sending simultaneously. ZeroMQ’s non-blocking sockets and the router design allow concurrent message emission. The router will fairly queue and distribute messages to subscribers. Likewise, multiple subscribers can receive the same published message if they share the topic. For example, if two different modules both subscribe to "memory" on the Memory Channel, and the memory module publishes an update targeted to "memory", both subscribers would receive it (assuming the memory module uses a generic target like a category; however, typically modules target specific recipients to avoid unintended listeners).
Cognitive Message Format
All data exchanged via the CMB conforms to the CognitiveMessage structure. This message schema is standardized to ensure interoperability across modules. In version 2, it is implemented as a Python dataclass for convenience and clarity. The key fields in a CognitiveMessage include:
message_id: A unique identifier (UUID) for the message instance, allowing tracking and correlation of messages.
source: The name of the module that generated the message (e.g., "executive"). Recipients can use this to understand who sent the information or to send a response back.
targets: A list of one or more target module names for whom the message is intended (e.g., ["behavior"]). These correspond to subscription topics on the bus. Multiple targets can be specified for multi-cast; if the list contains "all" or similar convention, it could be used for broadcast (this convention can be defined by the system).
payload: A dictionary containing the content of the message. This can be any JSON-serializable data structure (text, numbers, lists, nested dicts). The payload carries the substantive information or command — for example, a directive, a sensory observation, or a query result.
priority: An integer indicating the message priority or importance. By default, messages might have a priority of 50 (neutral), while critical messages could have higher values. In future, routers or modules could use priority to order message processing or to decide dropping low-priority messages under load.
timestamp: A sending time (epoch time in seconds) recorded when the message is created. This can be used for measuring latency or ordering events.
ttl (Time-To-Live): A duration (in seconds) that the message is considered valid. For example, ttl=10.0 means the message content expires 10 seconds after its timestamp. Receivers or routers can check this field to ignore or discard stale messages. In the current implementation, a helper method is_expired() is provided to check if the message’s TTL has elapsed. Future versions might have routers automatically drop expired messages instead of delivering them.
signature: A field for a cryptographic signature or hash. This is currently an empty string by default, but the intent is to allow messages to be signed for authenticity and integrity. In a future iteration, sending modules could sign the payload (or the entire message) with a private key, and receiving modules (or a security layer) could verify the signature to ensure the message was not tampered with and truly comes from the claimed source.
The CognitiveMessage class also provides convenience methods to convert to/from JSON or bytes for transmission. For instance, to_json() and to_bytes() serialize the message, and from_bytes() reconstructs a CognitiveMessage from raw bytes. The CMB uses these to send messages over sockets. Internally, when a message is sent via ModuleEndpoint.send(), it calls CognitiveMessage.to_bytes() and the router uses CognitiveMessage.from_bytes() when receiving on the other end. This ensures that the message structure remains consistent and no information is lost in transit.
By enforcing a standard message format, the CMB architecture ensures that all modules “speak the same language.” This is crucial for an integrative AGI system – perception outputs, executive commands, memory queries, etc., all share a common envelope, making it easier to log, debug, or extend the system.
Example Workflow
To illustrate how the CMB architecture operates in practice, consider a simple scenario where the Executive module commands the Behavior module to perform an action, and the Behavior responds or logs the action. This interaction uses the Control Channel (CC) and the Diagnostic Channel (DAC):
Executive Sends a Command: The Executive decides to trigger a behavior (e.g., “explore the area”). It creates a CognitiveMessage with source="executive" and targets=["behavior"] on the Control Channel. The message’s payload might be {"directive": "start_behavior", "behavior": "explore_area"}. The Executive’s ModuleEndpoint sends this message into the CMB via the CC router. (As shown in the code snippet earlier, this is a non-blocking send.) The executive can then continue its own processing or optionally wait for a response.
Control Channel Routing: The CC router (which was started for the Control Channel) receives the message on its ROUTER socket. It unwraps the frames, reconstructs the CognitiveMessage, and then iterates through the targets list. For the target "behavior", the router publishes the message on its PUB socket with topic "behavior". Any module subscribed to "behavior" on CC will get this message. In our case, the Behavior module is listening on CC for its name. The routing happens almost instantly and in a separate thread, so the Executive isn’t blocked. The router logs a debug output like “Routed message from executive to behavior via CC”, which helps in tracing the flow (and this could also be captured by a logging module on DAC, if configured).
Behavior Receives the Command: The Behavior module’s endpoint, which is subscribed to topic "behavior" on CC, picks up the published message. The behavior_endpoint.receive() call unblocks and returns the message to the Behavior’s code. The Behavior module inspects the message (sees the source and payload) and recognizes it as a directive from the Executive. It then proceeds to carry out the requested behavior (e.g., initiating a series of actions to explore the area). For our purposes, the Behavior stub simply prints a log: “Received message from executive with payload: {directive: 'start_behavior', ...}”. In a real system, this is where the behavior logic would take over.
Behavior Responds or Logs (Optional): After acting on the command, the Behavior module might need to send a confirmation or result back. There are multiple ways this could happen in CMB:
Reply on Control Channel: The Behavior could send a response message with source="behavior" and targets=["executive"] via the Control Channel, perhaps with payload {"status": "started", "behavior": "explore_area"}. The CC router would route this to the Executive (topic "executive"), allowing the Executive to receive it as a reply. This would be a simple request-reply over the bus (though not a direct socket reply, it’s an asynchronous message reply).
Log to Diagnostic Channel: Alternatively (or additionally), the Behavior might send a log message to the Diagnostic and Awareness Channel (DAC) to record that it has started the behavior. For example, it could create a message with source="behavior", targets=["cmb_logger"] on DAC, with payload {"event": "Behavior started", "behavior": "explore_area"}. The cmb_logger (a logging module subscribed on DAC) would receive and log this event. In the provided perception module stub, we saw a similar pattern where the Perception module sends status messages to a cmb_logger target. Logging via DAC ensures that there is a persistent record of actions and important state changes, which is invaluable for debugging and for the system’s self-monitoring.
Trigger Other Channels: If the Behavior execution leads to other cognitive processes, it might send messages on other channels. For instance, starting a behavior might involve querying memory (sending a question on MC – Memory Channel) or updating the world model (sending data on SMC or VB). Each of those would involve constructing new messages and sending them through the respective channel routers in a similar fashion.
Executive and Others Continue: The Executive, after sending the command, could carry on with other tasks. If it expects a reply, it would be listening on CC (or whichever channel) for a response targeted to "executive". Other modules in the system remain unaffected by this exchange because they are not subscribed to the “behavior” topic on CC. They might be busy with their own channel communications. For example, a Vision module might be streaming data on PC -> VB, the Memory module might be sending knowledge updates on MC, etc., all in parallel. The channels operate independently, but since modules can have multiple endpoints (one per channel if needed), information can still flow between different parts of the system in a coordinated way via the Executive or specialized mediator modules.
This workflow demonstrates the publish-subscribe messaging paradigm in action, coordinated by the CMB. It highlights how the architecture achieves decoupling (Executive doesn’t call Behavior directly, they communicate via messages) and flexibility (easy to log, monitor, or extend the interaction). It also shows how Version 2 improvements (like having a logger on DAC, using a structured message with TTL/priority) provide a more robust framework for building complex AI behaviors.
Improvements in Version 2 and Future Directions
CMB Architecture Version 2 incorporates several enhancements over the initial design to address completeness and expand functionality:
Comprehensive Channel Set: All original channels (CC, SMC, VB, BFC, DAC, EIG, PC, MC, IC, TC) are included with clear definitions, ensuring full coverage of the agent’s cognitive spaces. New channels can be added in a similar fashion if new domains of communication are identified. The central port mapping config makes this straightforward.
Standardized Message Schema: The CognitiveMessage dataclass formalizes the message content, adding fields like priority, ttl, and signature that were absent or implicit before. This makes messages self-descriptive and ready for future use cases (e.g., expiring unhandled messages, authenticating senders).
Code Snippets and Examples: Version 2 documentation (as seen above) now includes concrete code examples showing how to send and receive messages. This addresses previous ambiguity by demonstrating usage patterns of the CMB API (ModuleEndpoint, message creation, etc.) in a real context.
Diagnostic Logging Mechanism: The introduction of the Diagnostic channel (DAC) and a conceptual logging module (cmb_logger) provides a built-in way to capture and inspect the internal message flow. This was a recommended addition to improve observability – now every significant action can be emitted as a message and recorded, facilitating debugging and even training data for meta-cognitive analyses.
Threaded Router and Concurrency: The router component is designed to run on a separate thread per channel, which improves the system’s ability to handle multiple channels concurrently without bottlenecking the entire bus. This multi-threaded (or multi-process) architecture was an improvement to ensure scalability as more channels and higher message volumes are used.
Foundation for Identity-Based Routing: By using ZeroMQ’s ROUTER socket for input, the system is ready to leverage advanced routing patterns. Future versions could assign permanent identities to module endpoints, enabling direct addressability or request-reply semantics through the bus (where a message can specify a reply-to identity). Version 2 lays this groundwork, even though the current logic treats messages in a simple publish-subscribe manner.
Error Handling and Stability: Recommendations to handle errors more gracefully have been applied. The router’s loop catches exceptions during routing to prevent crashes and logs errors. The ModuleEndpoint will block or time out on receive, and send operations can be designed to use non-blocking sends with checks (for instance, the GUI demo catches exceptions if the send fails due to router unavailability). These practices increase the robustness of inter-module communication.
Extensibility for Security: With the signature field in place and the modular structure, adding security layers is more feasible. A future update might include encryption of message payloads or signatures verification on the receiving side (to ensure only authorized modules communicate or to detect tampering). The architecture can evolve to include a security broker or authentication service on a special channel (or integrated with each router) that verifies credentials of modules when they connect.
In terms of future directions, after finalizing Version 2, the next step would be to create a more elaborate demo showcasing multiple channels and modules working together. For example, a scenario could involve a Perception module sending data on the Perception Channel, a Memory module retrieving relevant info on Memory Channel, an Executive making a decision and issuing a command on Control Channel, and a Behavior module acting on it, all coordinated through the CMB. A visual dashboard could subscribe to the Diagnostic channel to display the message flow in real-time. Such a demo would validate the architecture’s design and illustrate its capabilities in a tangible way.
Version 2 of the CMB architecture thus provides a solid, well-documented foundation for building complex, modular AI systems. By incorporating structured messaging, multiple topic channels, and clear interfacing patterns, it addresses the shortcomings of the initial version. Modules can now communicate in a flexible yet organized manner, and developers have a clear guide on how to use the infrastructure (thanks to the examples and documentation). As the project moves forward, the CMB can be extended with new features (security, direct queries, load balancing across duplicate modules, etc.) without altering its core design. The current architecture is both comprehensive and adaptable, striking a balance that is crucial for the evolving needs of cognitive architectures and AGI research.
