# Terminology Conflict Report


## Intent

- (cmb_architecture_specification_v3_docx.txt) intent is to allow messages to be signed for authenticity and integrity.
- (cmb_architecture_v2_docx.txt) intent is to allow messages to be signed for authenticity and integrity.
- (cmb_architecture_v3_docx.txt) intent is to allow messages to be signed for authenticity and integrity.
- (cmb_architecture_v3_pdf.txt) intent is to allow messages to be signed for authenticity and integrity.


## Directive

- (Architecture – Agent Loop And Behavior Matrix (v1)_docx.txt) directive is interpreted into a structured Intent. An executive decision determines whether to respond, request clarification, or act. Actions are executed only through approved behaviors (skills). Results and artifacts are logged for traceability and replay. The system is explicitly designed so that reasoning, decision-making, and execution are separate concerns.  3.
- (Architecture – Directive And Intent Specification_docx.txt) Directive is any signal—external or internal—that expresses an intent requiring interpretation by the system.
- (Architecture – Directive And Intent Specification_docx.txt) directive is an intent-bearing input that requires semantic interpretation to determine the appropriate cognitive or behavioral response. Directives may originate from multiple sources and may vary widely in complexity, urgency, and required system involvement.  3.
- (Architecture – Intent Object Schema_docx.txt) directive is underspecified or ambiguous. When true, execution should pause pending additional input.  5.
- (Architecture – Section 3 Conceptual Model Of Work_docx.txt) directive is an explicit request or instruction, delivered through a UI, API, or upstream system.
- (architecture_agent_loop_and_behavior_matrix_v_1_md.txt) directive is interpreted into a structured Intent. 3.
- (architecture_directive_and_intent_specification_md.txt) directive is an intent-bearing input that requires semantic interpretation to determine the appropriate cognitive or behavioral response.  Directives may originate from multiple sources and may vary widely in complexity, urgency, and required system involvement.  ---  ## 3.
- (architecture_intent_object_schema_md.txt) directive is underspecified or ambiguous.  When true, execution should pause pending additional input.  ---  ## 5.


## Objective

- (Architecture – Objective Taxonomy And Priority Model (v1)_docx.txt) Objective is a structured representation of a desired condition or constraint.
- (Architecture – Objective Taxonomy And Priority Model (v1)_docx.txt) objective is not a plan, not a behavior, and not a question.
- (Architecture – Question Generation And Curiosity Subsystem (v1)_docx.txt) Objective is an active goal-state the system attempts to satisfy (e.g., safety, task completion, correctness, learning).
- (architecture_objective_taxonomy_and_priority_model_v_1_md.txt) objective is not a plan, not a behavior, and not a question.


## Behavior

- (AGI Architecture_docx.txt) behavior is complex (e.g., “make a cup of coffee”), the sequencer breaks it down into ordered steps (“grasp cup”, “pour water”, etc.), interacting with the Planner if needed to refine the sequence.
- (Architecture – Section 11 Learning And Behavior Extraction_docx.txt) Behavior is treated as an asset: a structured, reusable pattern of action that can be invoked in future work.
- (Architecture – Section 5 Decision And Behavior Model_docx.txt) Behavior is a reusable, executable pattern of action that the system can perform to advance work toward an outcome.
- (Architecture – Section 5 Decision And Behavior Model_docx.txt) behavior defines how something is done; tasks define when and in what order behaviors are executed within work.  5.7 Behavior Selection Behavior selection is the process of choosing which behavior to execute after a decision to act has been made. Selection may be based on: - rule‑based matching - priority tables - learned policies - historical performance - contextual similarity The architecture does not mandate a single selection mechanism.


## Message

- (ack state machine_docx.txt) Message is now router-owned Actions Stop router_ack_timer Start delivery_ack_timer Transitions  5.4 DELIVERED Description Router confirms module2 received message Execution responsibility now transferred Actions Log delivery confirmation Start execution_timer Transitions  5.5 EXECUTING Description Target module acknowledged execution start Long-running operation in progress Actions Continue waiting Optionally update UI / telemetry Transitions Important: in_progress ACKs reset or extend execution timers.  5.6 COMPLETED_SUCCESS Description Target module reports success Actions Finalize workflow Notify upstream logic Persist result if needed Next State IDLE  5.7 COMPLETED_FAILURE Description Target module reports failure Actions Log error Trigger recovery or retry policy Notify UI Next State IDLE (or retry loop if policy allows)  5.8 TIMEOUT_ABORT Description Sender-side timeout or cancel Actions Log failure Optionally send CANCEL to router/module Clean up resources Next State IDLE  6.
- (AGI Architecture_docx.txt) message is delivered to the cognitive layer (often handled by the Concept Processor).
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) message is delivered. Semantic concerns address what the message means. This separation allows the CMB to handle delivery, retries, and acknowledgments without influencing decisions, behaviors, or work structure. For example: - a transport failure may trigger a retry - a semantic failure may trigger a decision Conflating these leads to brittle systems; separating them enables clarity and robustness.  8.7 Message Envelope Concept Each message transported by the CMB is wrapped in a message envelope that contains two conceptual layers: Transport Envelope – Used by routers and infrastructure components Semantic Header and Payload – Used by system modules The transport envelope carries identifiers and metadata needed for delivery and reliability.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) message represents the transfer of information or intent from one module to another. Messages may represent: - events (observations, state changes) - commands (requests for action) - execution progress - acknowledgments - error notifications Messages are structured, typed, and self-describing.
- (Cmb Ack Vocabulary Specification_docx.txt) Message is successfully written to the outbound ZeroMQ socket Description: Confirms physical dispatch of the message from the endpoint.  3.
- (Cmb Ack Vocabulary Specification_docx.txt) Message is resent due to timeout or transient failure.  7.
- (Cmb Architecture outlineVersion 2_docx.txt) message is sent on exactly one channel Channels must not be repurposed Modules may participate in multiple channels Channel choice encodes intent  4.
- (Cmb Architecture – Documentation Invariants And Design Notes_docx.txt) message is delivered) Routing policy (where the message goes) Semantic meaning belongs in the message schema, not in: - Port numbers - Socket types - Hardcoded topology  7.
- (cmb_architecture_specification_v3_docx.txt) message is delivered) Routing policy (where the message goes) Semantic meaning belongs in the message schema, not in: - Port numbers - Socket types - Hardcoded topology Improvements in Version 3 CMB Architecture Version 3 incorporates several enhancements over the initial design to address completeness and expand functionality: Comprehensive Channel Set: All original channels (CC, SMC, VB, BFC, DAC, EIG, PC, MC, IC, TC) are included with clear definitions, ensuring full coverage of the agent’s cognitive spaces.
- (cmb_architecture_specification_v3_docx.txt) message is sent on exactly one channel Channels must not be repurposed Modules may participate in multiple channels Channel choice encodes intent  Naming Conventions and Port Assignments Channel Ownership Ports identify channels, not participants. A channel represents a semantic communication purpose (e.g., COMMAND, BFC, DAC), not a specific module. Multiple modules may connect to the same channel using unique identities. Channel membership is determined by subscription and identity, not by port allocation. Lifecycle and Control Channels Lifecycle channels are reserved for: Module registration Heartbeats and liveness Shutdown and control commands These channels are bidirectional via the router only. Modules must never issue lifecycle commands directly to other modules. This design enables safe startup, shutdown, and fault handling.   CMB Router For each channel, a CMBRouter instance is responsible for shuttling messages from senders to receivers.
- (cmb_architecture_specification_v3_docx.txt) message is forwarded to the CC router, which will route it to the Behavior module as described earlier.
- (cmb_architecture_specification_v3_docx.txt) message is intended (e.g., ["behavior"]).
- (cmb_architecture_specification_v3_docx.txt) message is created.
- (cmb_architecture_specification_v3_docx.txt) message is considered valid.
- (cmb_architecture_specification_v3_docx.txt) message is sent via ModuleEndpoint.send(), it calls CognitiveMessage.to_bytes() and the router uses CognitiveMessage.from_bytes() when receiving on the other end.
- (cmb_architecture_specification_v3_docx.txt) Message is now router-owned Actions Stop router_ack_timer Start delivery_ack_timer Transitions  DELIVERED Description Router confirms module2 received message Execution responsibility now transferred Actions Log delivery confirmation Start execution_timer Transitions  EXECUTING Description Target module acknowledged execution start Long-running operation in progress Actions Continue waiting Optionally update UI / telemetry Transitions Important: in_progress ACKs reset or extend execution timers.  COMPLETED_SUCCESS Description Target module reports success Actions Finalize workflow Notify upstream logic Persist result if needed Next State IDLE  COMPLETED_FAILURE Description Target module reports failure Actions Log error Trigger recovery or retry policy Notify UI Next State IDLE (or retry loop if policy allows)  TIMEOUT_ABORT Description Sender-side timeout or cancel Actions Log failure Optionally send CANCEL to router/module Clean up resources Next State IDLE  Timers (Critical Design Detail) Each phase has independent timers: Timers must not overlap ambiguously. This avoids a common bug: “Execution timed out” when delivery never occurred. Transition Event Emission (Normative) The ACK state machine must not perform logging or I/O.
- (cmb_architecture_v1_docx.txt) message is received, the Awareness subsystem performs standard processing steps: Validate message integrity and schema. Assess severity, scope, and urgency. Query current system state (active goals, load, errors). Generate a structured awareness context. Forward context and questions to an LLM-based evaluator. Receive corrective recommendations. Execute approved corrective procedures. Log actions and notify affected modules. 5.1 Core Awareness Questions (Initial Set) What subsystem is affected? Is the anomaly transient or persistent? Does this impact current goals or safety? What recent events preceded this condition? Are similar events recorded in memory? What corrective actions are available? What is the cost and risk of each action? Should human or external intervention be requested?  6.
- (cmb_architecture_v2_docx.txt) message is forwarded to the CC router, which will route it to the Behavior module as described earlier.
- (cmb_architecture_v2_docx.txt) message is intended (e.g., ["behavior"]).
- (cmb_architecture_v2_docx.txt) message is created.
- (cmb_architecture_v2_docx.txt) message is considered valid.
- (cmb_architecture_v2_docx.txt) message is sent via ModuleEndpoint.send(), it calls CognitiveMessage.to_bytes() and the router uses CognitiveMessage.from_bytes() when receiving on the other end.
- (cmb_architecture_v3_docx.txt) message is delivered) Routing policy (where the message goes) Semantic meaning belongs in the message schema, not in: - Port numbers - Socket types - Hardcoded topology Improvements in Version 3 CMB Architecture Version 3 incorporates several enhancements over the initial design to address completeness and expand functionality: Comprehensive Channel Set: All original channels (CC, SMC, VB, BFC, DAC, EIG, PC, MC, IC, TC) are included with clear definitions, ensuring full coverage of the agent’s cognitive spaces.
- (cmb_architecture_v3_docx.txt) message is sent on exactly one channel Channels must not be repurposed Modules may participate in multiple channels Channel choice encodes intent  Naming Conventions and Port Assignments Channel Ownership Ports identify channels, not participants. A channel represents a semantic communication purpose (e.g., COMMAND, BFC, DAC), not a specific module. Multiple modules may connect to the same channel using unique identities. Channel membership is determined by subscription and identity, not by port allocation. Lifecycle and Control Channels Lifecycle channels are reserved for: Module registration Heartbeats and liveness Shutdown and control commands These channels are bidirectional via the router only. Modules must never issue lifecycle commands directly to other modules. This design enables safe startup, shutdown, and fault handling.  CMB Router For each channel, a CMBRouter instance is responsible for shuttling messages from senders to receivers.
- (cmb_architecture_v3_docx.txt) message is forwarded to the CC router, which will route it to the Behavior module as described earlier.
- (cmb_architecture_v3_docx.txt) message is intended (e.g., ["behavior"]).
- (cmb_architecture_v3_docx.txt) message is created.
- (cmb_architecture_v3_docx.txt) message is considered valid.
- (cmb_architecture_v3_docx.txt) message is sent via ModuleEndpoint.send(), it calls CognitiveMessage.to_bytes() and the router uses CognitiveMessage.from_bytes() when receiving on the other end.
- (cmb_architecture_v3_docx.txt) Message is now router-owned Actions Stop router_ack_timer Start delivery_ack_timer Transitions  DELIVERED Description Router confirms module2 received message Execution responsibility now transferred Actions Log delivery confirmation Start execution_timer Transitions  EXECUTING Description Target module acknowledged execution start Long-running operation in progress Actions Continue waiting Optionally update UI / telemetry Transitions Important: in_progress ACKs reset or extend execution timers.  COMPLETED_SUCCESS Description Target module reports success Actions Finalize workflow Notify upstream logic Persist result if needed Next State IDLE  COMPLETED_FAILURE Description Target module reports failure Actions Log error Trigger recovery or retry policy Notify UI Next State IDLE (or retry loop if policy allows)  TIMEOUT_ABORT Description Sender-side timeout or cancel Actions Log failure Optionally send CANCEL to router/module Clean up resources Next State IDLE  Timers (Critical Design Detail) Each phase has independent timers: Timers must not overlap ambiguously. This avoids a common bug: “Execution timed out” when delivery never occurred.   Modules The following modules are part of the CMB.
- (cmb_architecture_v3_pdf.txt) message is delivered) • Routing policy (where the message goes) Semantic meaning belongs in the message schema, not in: - Port numbers - Socket types - Hardcoded topology Improvements in Version 3 CMB Architecture Version 3 incorporates several enhancements over the initial design to address completeness and expand functionality: • Comprehensive Channel Set: All original channels (CC, SMC, VB, BFC, DAC, EIG, PC, MC, IC, TC) are included with clear definitions, ensuring full coverage of the agent’s cognitive spaces.
- (cmb_architecture_v3_pdf.txt) message is sent on exactly one channel • Channels must not be repurposed • Modules may participate in multiple channels • Channel choice encodes intent Naming Conventions and Port Assignments Port Range Channel Router Socket Module Logical Socket Direction 60XX CMB Channels (Ingress) 6001 CC ROUTER DEALER Ingress 6002 SMC ROUTER DEALER Ingress 6003 VB ROUTER DEALER Ingress 6004 BFC ROUTER DEALER Ingress 6005 DAC ROUTER DEALER Ingress 6006 EIG ROUTER DEALER Ingress 6007 PC ROUTER DEALER Ingress 6008 MS ROUTER DEALER Ingress 6009 IC ROUTER DEALER Ingress 6010 TC ROUTER DEALER Ingress 70XX Fanout Channels(Egress) 7001 CC PUB SUB Egress 7002 SMC PUB SUB Egress 7003 VB PUB SUB Egress 7004 BFC PUB SUB Egress 7005 DAC PUB SUB Egress 7006 EIG PUB SUB Egress 7007 PC PUB SUB Egress 7008 MS PUB SUB Egress 7009 IC PUB SUB Egress 7010 TC PUB SUB Egress 61XX Acknowledge (Directed/Shared) 6101 ACK Ingress ROUTER DEALER Ingress 6102 ACK Egress ROUTER DEALER Egress 62XX Lifecycle/control 6200 Registration ROUTER DEALER Bidirectional (via router) 6201 Control/Shutdown ROUTER DEALER Bidirectional (via router) Channel Ownership • Ports identify channels, not participants. • A channel represents a semantic communication purpose (e.g., COMMAND, BFC, DAC), not a specific module. • Multiple modules may connect to the same channel using unique identities. Channel membership is determined by subscription and identity, not by port allocation. Lifecycle and Control Channels • Lifecycle channels are reserved for: o Module registration o Heartbeats and liveness o Shutdown and control commands • These channels are bidirectional via the router only. • Modules must never issue lifecycle commands directly to other modules. This design enables safe startup, shutdown, and fault handling. CMB Router For each channel, a CMBRouter instance is responsible for shuttling messages from senders to receivers.
- (cmb_architecture_v3_pdf.txt) message is forwarded to the CC router, which will route it to the Behavior module as described earlier.
- (cmb_architecture_v3_pdf.txt) message is intended (e.g., ["behavior"]).
- (cmb_architecture_v3_pdf.txt) message is created.
- (cmb_architecture_v3_pdf.txt) message is considered valid.
- (cmb_architecture_v3_pdf.txt) message is sent via ModuleEndpoint.send(), it calls CognitiveMessage.to_bytes() and the router uses CognitiveMessage.from_bytes() when receiving on the other end.
- (cmb_architecture_v3_pdf.txt) Message is now router-owned Actions • Stop router_ack_timer • Start delivery_ack_timer Transitions Event Next State DELIVERY_ACK DELIVERED Timeout TIMEOUT_ABORT DELIVERED Description • Router confirms module2 received message • Execution responsibility now transferred Actions • Log delivery confirmation • Start execution_timer Transitions Event Next State EXECUTION_ACK(status=in_progress) EXECUTING EXECUTION_ACK(status=success) COMPLETED_SUCCESS EXECUTION_ACK(status=failure) COMPLETED_FAILURE Timeout TIMEOUT_ABORT EXECUTING Description • Target module acknowledged execution start • Long-running operation in progress Actions • Continue waiting • Optionally update UI / telemetry Transitions Event Next State EXECUTION_ACK(status=success) COMPLETED_SUCCESS EXECUTION_ACK(status=failure) COMPLETED_FAILURE Timeout TIMEOUT_ABORT CANCEL TIMEOUT_ABORT Important: in_progress ACKs reset or extend execution timers. COMPLETED_SUCCESS Description • Target module reports success Actions • Finalize workflow • Notify upstream logic • Persist result if needed Next State • IDLE COMPLETED_FAILURE Description • Target module reports failure Actions • Log error • Trigger recovery or retry policy • Notify UI Next State • IDLE (or retry loop if policy allows) TIMEOUT_ABORT Description • Sender-side timeout or cancel Actions • Log failure • Optionally send CANCEL to router/module • Clean up resources Next State • IDLE Timers (Critical Design Detail) Each phase has independent timers: Timer Purpose router_ack_timer Router responsiveness delivery_ack_timer Routing completion execution_timer Module execution Timers must not overlap ambiguously. This avoids a common bug: “Execution timed out” when delivery never occurred. CMB Supporting Modules The following modules are part of the CMB.
- (cmb_comments_v1_docx.txt) message is published: ❌ Message is lost No error No retry Solution: Start subscribers first Or add a sync barrier (REQ/REP handshake) if needed  2.


## Event

- (Architecture – Section 4 Event Model_docx.txt) Event is a recorded observation of something relevant that occurred at a specific point in the lifecycle of work.
- (Architecture – Section 4 Event Model_docx.txt) event is never altered. Contextual – Events exist within the context of a Work Instance. Typed – Every event has a category that explains its role in execution. Events are not free-form log messages.
- (Architecture – Section 4 Event Model_docx.txt) event is therefore assigned a sequence number scoped to its Work Instance.
- (Architecture – Section 4 Event Model_docx.txt) event represents something the system can observe, detect, or infer. Immutable – Once recorded, an event is never altered. Contextual – Events exist within the context of a Work Instance. Typed – Every event has a category that explains its role in execution. Events are not free-form log messages.
- (Architecture – Termination Metrics And Inquiry Budgets (v1)_docx.txt) Event is a decision point where the system ends the current question episode and returns control to the Agent Loop.  4.
- (Cmb Ack Vocabulary Specification_docx.txt) event is associated with exactly one transaction, identified by correlation_id. State-machine authoritative The ACK State Machine is the sole authority for deciding transaction state transitions.  Canonical ACK Events The following events are the only valid inputs to the ACK State Machine. 1.


## ACK

- (ARCHITECTURE_DATA_STRUCTURES_docx.txt) ack is required.  ---  Dataclass: `MessageEnvelope`  **Purpose**: The standard CMB message object combining transport + semantic header + payload.  **Owner**: Source module; routers forward without interpreting payload  **Fields**  `transport: TransportHeader` — Transport metadata. `semantic: SemanticHeader` — Semantic metadata. `payload: dict[str, Any]` — The content. `signature: str | None` — Optional signature.  **Users**  **Endpoints** — *Create* and *Read*. **Routers** — *Read*: `transport`; *Write*: `attempt` only; do not change semantic/payload.  ---  Dataclass: `TransactionRecord`  **Purpose**: Tracks delivery lifecycle for one outbound message exchange (timeouts, retries, ack).  **Owner**: Module Endpoint (sender-side)  **Fields**  `xid: str` — Transaction ID. `wid: str | None` — Optional work linkage. `envelope_hash: str` — Stable hash of message envelope for diagnostics. `created_ts: float` — Created. `last_send_ts: float | None` — Last send. `status: str` — `pending|acked|failed|expired`. `attempts: int` — Send attempts. `timeout_s: float` — Timeout threshold. `error_id: str | None` — Error reference if failed.  **Users**  **Endpoint** — *Create/Write*. **Persistence** — *Write* finalized records. **Error subsystem** — *Read* to correlate failures.  ---  Section 9 — Persistence and Replay  Dataclass: `EventStoreAppendResult`  **Purpose**: Standard result returned by event store append operations.  **Owner**: Event Store  **Fields**  `wid: str` — Work ID. `eid: str` — Event ID. `esn: int` — Assigned sequence. `persisted: bool` — True if committed. `storage_ref: str | None` — DB row id / URI.  ---  Dataclass: `ReplayRequest`  **Purpose**: Requests full/partial replay of stored execution.  **Owner**: Replay Engine  **Fields**  `replay_id: str` — Replay session id. `wid: str` — Work to replay. `mode: str` — `full|partial|what_if`. `from_esn: int | None` — Optional start. `to_esn: int | None` — Optional end. `side_effects: str` — `disabled|simulated|enabled`. `overrides: dict[str, Any]` — Optional alternative decision/behavior logic hints.  ---  Section 10 — Error Handling and Recovery  Dataclass: `ErrorRecord`  **Purpose**: Structured error object (also recorded as an Error Event) for system-wide reporting and persistence.  **Owner**: Error Reporting Subsystem  **Fields**  `error_id: str` — Unique error id. `wid: str | None` — Optional work linkage. `task_id: str | None` — Optional task linkage. `xid: str | None` — Optional transport transaction linkage. `ts: float` — Timestamp. `category: str` — `validation|transport|execution|external|policy|safety`. `severity: str` — `warn|error|critical`. `source_module: str` — Where it occurred. `message: str` — Human-readable description. `details: dict[str, Any]` — Structured diagnostics (exception class, stack summary, timeouts, etc.). `recovery_action: str | None` — `retry|fallback|defer|escalate|abort|none`.  **Users**  **All modules** — *Create*: reports errors to subsystem. **Error subsystem** — *Write*: persists; creates correlated events. **Executive** — *Read*: decide recovery/escalation.  ---  Section 11 — Learning and Behavior Extraction  Dataclass: `BehaviorCandidate`  **Purpose**: Candidate extracted from successful repeated work patterns before promotion.  **Owner**: Learning/Behavior Extraction Pipeline  **Fields**  `candidate_id: str` — Unique id. `source_wids: list[str]` — Work instances used as evidence. `pattern_summary: str` — Human summary of extracted pattern. `applicability: list[str]` — When candidate applies. `proposed_behavior: BehaviorSpec` — Proposed behavior spec. `metrics: dict[str, float]` — Reliability/latency/utility metrics. `status: str` — `identified|normalized|validated|rejected|promoted`.  ---  Dataclass: `OutcomeRecord`  **Purpose**: Terminal outcome evaluation for work (success/partial/failure/aborted/expired).  **Owner**: Executive  **Fields**  `wid: str` — Work ID. `outcome_type: str` — Outcome class. `ts: float` — Timestamp. `summary: str` — Human-readable statement. `metrics: dict[str, float]` — Performance/utilization/quality measures. `artifacts: dict[str, str]` — References to produced outputs (file ids, URLs, DB keys).  ---  Required Structures for Initial Human-Directive Flow  Dataclass: `DirectiveDerivative`  **Purpose**: The NLP-derived structure created from a human directive plus LLM analysis.
- (ARCHITECTURE_DATA_STRUCTURES_md.txt) ack is required.  ---  ## Dataclass: `MessageEnvelope`  **Purpose**: The standard CMB message object combining transport + semantic header + payload.  **Owner**: Source module; routers forward without interpreting payload  **Fields**  - `transport: TransportHeader` — Transport metadata. - `semantic: SemanticHeader` — Semantic metadata. - `payload: dict[str, Any]` — The content. - `signature: str | None` — Optional signature.  **Users**  - **Endpoints** — *Create* and *Read*. - **Routers** — *Read*: `transport`; *Write*: `attempt` only; do not change semantic/payload.  ---  ## Dataclass: `TransactionRecord`  **Purpose**: Tracks delivery lifecycle for one outbound message exchange (timeouts, retries, ack).  **Owner**: Module Endpoint (sender-side)  **Fields**  - `xid: str` — Transaction ID. - `wid: str | None` — Optional work linkage. - `envelope_hash: str` — Stable hash of message envelope for diagnostics. - `created_ts: float` — Created. - `last_send_ts: float | None` — Last send. - `status: str` — `pending|acked|failed|expired`. - `attempts: int` — Send attempts. - `timeout_s: float` — Timeout threshold. - `error_id: str | None` — Error reference if failed.  **Users**  - **Endpoint** — *Create/Write*. - **Persistence** — *Write* finalized records. - **Error subsystem** — *Read* to correlate failures.  ---  # Section 9 — Persistence and Replay  ## Dataclass: `EventStoreAppendResult`  **Purpose**: Standard result returned by event store append operations.  **Owner**: Event Store  **Fields**  - `wid: str` — Work ID. - `eid: str` — Event ID. - `esn: int` — Assigned sequence. - `persisted: bool` — True if committed. - `storage_ref: str | None` — DB row id / URI.  ---  ## Dataclass: `ReplayRequest`  **Purpose**: Requests full/partial replay of stored execution.  **Owner**: Replay Engine  **Fields**  - `replay_id: str` — Replay session id. - `wid: str` — Work to replay. - `mode: str` — `full|partial|what_if`. - `from_esn: int | None` — Optional start. - `to_esn: int | None` — Optional end. - `side_effects: str` — `disabled|simulated|enabled`. - `overrides: dict[str, Any]` — Optional alternative decision/behavior logic hints.  ---  # Section 10 — Error Handling and Recovery  ## Dataclass: `ErrorRecord`  **Purpose**: Structured error object (also recorded as an Error Event) for system-wide reporting and persistence.  **Owner**: Error Reporting Subsystem  **Fields**  - `error_id: str` — Unique error id. - `wid: str | None` — Optional work linkage. - `task_id: str | None` — Optional task linkage. - `xid: str | None` — Optional transport transaction linkage. - `ts: float` — Timestamp. - `category: str` — `validation|transport|execution|external|policy|safety`. - `severity: str` — `warn|error|critical`. - `source_module: str` — Where it occurred. - `message: str` — Human-readable description. - `details: dict[str, Any]` — Structured diagnostics (exception class, stack summary, timeouts, etc.). - `recovery_action: str | None` — `retry|fallback|defer|escalate|abort|none`.  **Users**  - **All modules** — *Create*: reports errors to subsystem. - **Error subsystem** — *Write*: persists; creates correlated events. - **Executive** — *Read*: decide recovery/escalation.  ---  # Section 11 — Learning and Behavior Extraction  ## Dataclass: `BehaviorCandidate`  **Purpose**: Candidate extracted from successful repeated work patterns before promotion.  **Owner**: Learning/Behavior Extraction Pipeline  **Fields**  - `candidate_id: str` — Unique id. - `source_wids: list[str]` — Work instances used as evidence. - `pattern_summary: str` — Human summary of extracted pattern. - `applicability: list[str]` — When candidate applies. - `proposed_behavior: BehaviorSpec` — Proposed behavior spec. - `metrics: dict[str, float]` — Reliability/latency/utility metrics. - `status: str` — `identified|normalized|validated|rejected|promoted`.  ---  ## Dataclass: `OutcomeRecord`  **Purpose**: Terminal outcome evaluation for work (success/partial/failure/aborted/expired).  **Owner**: Executive  **Fields**  - `wid: str` — Work ID. - `outcome_type: str` — Outcome class. - `ts: float` — Timestamp. - `summary: str` — Human-readable statement. - `metrics: dict[str, float]` — Performance/utilization/quality measures. - `artifacts: dict[str, str]` — References to produced outputs (file ids, URLs, DB keys).  ---  # Required Structures for Initial Human-Directive Flow  ## Dataclass: `DirectiveDerivative`  **Purpose**: The NLP-derived structure created from a human directive plus LLM analysis.


## Reflection

- (Architecture – Reflection And Self-assessment Layer (v1)_docx.txt) Reflection is entered after termination of questioning and/or execution, and before the next directive or perception cycle.  4.
- (Architecture – Reflection And Self-assessment Layer (v1)_docx.txt) Reflection is the natural insertion point for beliefs and values: Was this action aligned with my values? Did I prioritize correctly? Should I refuse similar requests in the future? This layer provides the mechanism; belief/value content comes later.  12.
- (architecture_reflection_and_self_assessment_layer_v_1_md.txt) Reflection is entered **after termination of questioning and/or execution**, and before the next directive or perception cycle.  ---  ## 4.
- (architecture_reflection_and_self_assessment_layer_v_1_md.txt) Reflection is the natural insertion point for beliefs and values:  - Was this action aligned with my values? - Did I prioritize correctly? - Should I refuse similar requests in the future?  This layer provides the *mechanism*; belief/value content comes later.  ---  ## 12.


## Question

- (AGI Architecture_docx.txt) question is how to architect this without complicating the main cognitive loop.
- (AGI Architecture_docx.txt) question is whether the AGI needs a dedicated module to model other minds and social context (a Theory of Mind module).
- (AGI Architecture_docx.txt) question is how the system will improve its own algorithms over time.
- (Architecture – Question Generation And Curiosity Subsystem (v1)_docx.txt) Question is a structured request for information or evaluation, expressed either internally (machine form) or externally (natural language), intended to reduce uncertainty, validate outcomes, or guide decision-making. 3.2 Curiosity Curiosity is a trigger mechanism that activates exploration when uncertainty or novelty crosses a threshold and is judged sufficiently relevant to current objectives and priorities. 3.3 Objective An Objective is an active goal-state the system attempts to satisfy (e.g., safety, task completion, correctness, learning).
- (Architecture – Question Template Schema (v1)_docx.txt) Question is an instantiated template with bound variables, asked during a question episode. 3.3 Template Binding Binding is the process of taking a template and substituting context values (entity, location, artifact type, threshold, etc.).  4.


## CMB

- (AGI Architecture_docx.txt) CMB is logically divided into multiple channels, each serving a category of information flow, which provides both organization and parallelism: Control Channel (CC): Handles high-level control signals and lifecycle management.
- (AGI Architecture_docx.txt) CMB is arguably the most critical infrastructure in the ASP design.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) CMB is therefore a subsystem, not the architecture itself.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) CMB is designed around a small number of guiding principles: Semantic Agnosticism – The bus does not interpret meaning; it transports context. Explicit Context Propagation – Messages carry identifiers and metadata needed for traceability. Reliability Without Coupling – Delivery guarantees do not leak into decision logic. Scalability by Decomposition – Communication patterns support modular growth. Observability by Design – Transport activity is itself observable and traceable. These principles ensure that communication supports the system without constraining how intelligence is implemented.  8.3 What the CMB Is (and Is Not) What the CMB Is A logical messaging fabric connecting system modules A mechanism for routing events, commands, and execution signals A carrier of identity and traceability metadata A foundation for reliability, retries, and acknowledgments What the CMB Is Not A decision engine A workflow engine A global state manager A substitute for shared semantic models This distinction is critical.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) CMB is the message.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) CMB is wrapped in a message envelope that contains two conceptual layers: Transport Envelope – Used by routers and infrastructure components Semantic Header and Payload – Used by system modules The transport envelope carries identifiers and metadata needed for delivery and reliability.
- (Architecture – Section 8 Communication Architecture (cmb)_docx.txt) CMB is the primary vehicle by which identity and traceability information flows between modules.
- (Cmb Architecture outlineVersion 2_docx.txt) CMB is the integration contract binding all ASP layers.
- (cmb_comments_v1_docx.txt) CMB is no longer speculative — it’s an integration contract Isolating CMB prevents: Channel sprawl Message semantic drift “Bus does everything” syndrome This is exactly how large real systems are designed: system architecture first → communication contract second → code last  What We’ll Do in the CMB Conversation (Preview) Once the new chat starts, the natural progression will be: Validate channel list against ASP layers For each channel: Sender modules Receiver modules Message purposes Define: Message envelopes Message types Required vs optional fields Formalize supporting CMB modules: DAC Registry Validator Tracer Only then talk about code stubs The following are some ideas and comments I had after reviewing the first part of the CMB architecture. Section 1 – CMB Architecture Each channel needs a list of messages with the flow from module to module including a description of the purpose of the message. Section 2.1 Show the layout of the message structure.


## Persistence

- (Architecture – Section 9 Persistence And Replay Architecture_docx.txt) persistence is treated as a storage concern and replay as a debugging convenience.
- (Architecture – Section 9 Persistence And Replay Architecture_docx.txt) Persistence is therefore designed alongside communication, identity, and execution—not layered on later.  9.3 What Must Be Persisted The architecture distinguishes between what must be persisted and what may be transient. Persisted Artifacts (Authoritative Record) The following artifacts form the minimum persistent record: Work Records – Work identity, lifecycle state, start/end markers Event Records – Event identity, type, sequence, timestamps, causality Decision Records – Decision identity, inputs, selected outcomes Task Records – Task identity, execution state transitions Outcome Records – Success/failure evaluations Transport Summaries – Transaction outcomes and failure reasons Together, these artifacts define the execution narrative of the system. Transient Artifacts Examples of data that may remain transient include: - in-memory queues - active retry timers - ephemeral caches These are implementation details, not part of the architectural record.  9.4 Append-Only Event Persistence Model The core persistence mechanism is an append-only event store scoped by Work Instance.
- (Architecture – Section 9 Persistence And Replay Architecture_docx.txt) Persistence is not only about correctness; it is about improvement.
- (Architecture – Section 9 Persistence And Replay Architecture_docx.txt) Persistence is the backbone that makes these sections operationally meaningful.  9.12 Practical Implications for Implementation From an implementation perspective, this section implies: An append-only event store with strong ordering guarantees. Explicit persistence points for work, decision, and outcome records. Replay tooling that can consume persisted artifacts. Clear separation between live execution and replay environments. Early implementation stubs should: - persist events immediately after creation - reconstruct state from persisted history - demonstrate replay of a simple work instance  9.13 Summary The Persistence and Replay Architecture ensures that system execution is durable, analyzable, and improvable.
- (cmb_architecture_specification_v3_docx.txt) persistence is trivial - Trace reconstruction is deterministic - GUI timelines require no socket inspection  Architectural Guarantee This event-emission model ensures: - deterministic replay - auditability - clean separation of concerns - long-term extensibility (OpenTelemetry, distributed tracing)  State Machine Integration Pattern The ACK state machine performs transitions exclusively through a single internal helper: def _transition(self, new_state: AckState, *, reason: str, details=None):     event = AckTransitionEvent(         message_id=self.message_id,         old_state=self.state.name,         new_state=new_state.name,         reason=reason,         timestamp=time.monotonic(),         retry_count=self.retry_count,         details=details,     )     self.state = new_state     self.last_transition_at = event.timestamp     return event All public handlers (on_send, on_router_ack, on_exec_ack, on_timeout) must return the event produced by _transition().  Example: ROUTER_ACK Handling def on_router_ack(self):     if self.require_exec_ack:         return self._transition(             AckState.AWAIT_EXEC_ACK,             reason="ROUTER_ACK",         )     else:         return self._transition(             AckState.COMPLETED_SUCCESS,             reason="ROUTER_ACK_NO_EXEC",         )  Endpoint Responsibility The ModuleEndpoint: 1.
